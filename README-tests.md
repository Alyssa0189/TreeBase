###Testing procedures
  
**launch scripts:**  
  
* unit test: cloning the code base
    * Input: a git repository owner and name
    * Output: a copy of the repository in the 'codebase' folder
    * Test: compare repository files on disk against repository files on git
* unit test: getting the list of all commit hashes of a repo
    * Input: a code base from a git repository for which you know the commit hashes
    * Output: a list of hashes for each commit of a repo (latest commit hash at the top)
    * Test: diff against the expected hashes; check the size of the list to ensure that it matches the total number of commits
* unit test: checking out a particular commit of the code base
    * Input: a code base's commit hash
    * Output: a copy of the repository at that commit in the 'codebase' folder
    * Test: compare repository files on disk against repository files on git for that commit
* integration test: calling Ant to run JCSC (code quality tool) once
    * Input: a directory containing a code base
    * Output: a set of XML files containing the analysis results in the 'jcsc-output/(commit hash)' folder
    * Test: run JCSC on the code base manually and compare the XML files produced
* integration test: calling Ant to run JCSC on all commits
    * Input: a directory containing a code base
    * Output: same as above, except there is a 'jcsc-output/(commit hash)' folder for *each* commit
    * Test: count the number of folders in the 'jcsc-output' folder to ensure that it matches the total number of commits; run JSCS on some commits of the code base manually and compare the XML files produced
* integration test: running the commit info tool
    * Input: a code base for which you know the commit info
    * Output: 'jsonastxt.txt' in the 'src/gitHubParser/output' directory
    * Test: confirm that the text file exists; inspect the text file to confirm that it parses correctly (see tests below for more detailed commit tool tests)
* integration test: running the fuser
    * Input: a code base for which you know the commit info and code quality
    * Output: 'codequalityoutput.txt' and 'numberofcommitsoutput.txt' in the 'src/fuser/output' directory
    * Test: confirm that the text files exist; inspect the text files to confirm that it parses correctly (see tests below for more detailed fuser tests)
* integration test: running the visualization tool
    * Input: a code base for which you know roughly what the visualization should look like
    * Output: a set of tree .png images and 'TreeVideo.mp4' in the 'src/visualizer/treeFrames' directory
    * Test: confirm that the trees in the images/video have the correct height and 'liveliness' for each commit
  
**commit info tool:**  
  
* (visual tests, manual)
    * Input: a GitHub-hosted repository
    * Output: a text file containing JSON-formatted information for all commits in the 'src/gitHubParser/output' directory
    * Tests:
        * confirm that each element in the file contains a commit number, author, and commit time
        * confirm that the number of commits in the file matches the number of commits in the repository
        * compare values for author and time in the file to those in the repository (e.g., look at the most recent commits on the repository on GitHub itself and confirm that they have the same authors/times as those in the file)
        * confirm that commits in the file starting at commitNumber0 refer to the latest commit in the repository
  
**fuser:**  
  
* (Visual test, Manual)
	* Input: files generated by JCSC in 'jcsc-output' folder
	* Output: violation number from each file in a list format. For example: [2008, 3000, 5788]
	* Test: This will test if correct data is obtained from input file.
		* Compare against the expected value (in the 'overview.xml' input files) to output printed in the console by System.out.println(violationList) command.

* (Visual test, Manual)
	* Input: 'jsonastxt.txt' in 'src/gitHubParser/output' folder
	* Output: list of total number of commits from all files. For example: [1, 2, 3, 4, 5, 6]
	* Test: This will test if correct data is obtained from input file.
		* Compare number of commits in input file to the output printed in console by System.out.println(commitNumberList) command.

* (Visual test, Manual)
	* Input: array list of violations and array list of number of commits
	* Output: 'codequalityoutput.txt' and 'numberofcommitsoutput.txt' files in 'src/fuser/output' folder
	* Test: This will test writeToFile method.
		* Compare number of commits and number of violations in the jcsc and jsonastxt input files to the result obtained in the two output files produced in 'src/fuser/output' folder.
  
**visualizer:**  
  
*  (manual test):
	* Input: Dummy commit and code quality data files.
	* Output: A sequence of images.
	* Test A:
        * Edit TreeVisualizer.py so that commitDataFileName = "/visualizer/tests/mockCommitData0.txt"
        * Edit TreeVisualizer.py so that qualityDataFileName = "/visualizer/tests/mockQualityData0.txt"
        * Enter "blender treeVisualizer.blend --background --python TreeVisualizer.py" in the terminal.
        * Check the folder /src/visualizer/treeFrames to ensure that:
            - There are 6 ordered .png images of trees.
            - Each tree is taller than the last.
            - Each tree is less green than the one before it.

	* Test B:
        * Edit file as above except with "mockCommitData1.txt" and "mockQualityData1.txt".
        * Check the folder /src/visualizer/treeFrames to ensure that:
            - There are 8 ordered. png images of trees.
            - Each tree is shorter than the last.
            - Each tree is greener than the last.
        * Remove the images from /treeframes/

	* Test C:
        * Edit file as above except with "mockCommitData2.txt" and "mockQualityData1.txt".
        * Check the folder /src/visualizer/treeFrames to ensure that:
            - There are 6 ordered .png images of trees.
            - The second tree is greener than the first.
            - Each tree is one of two colors, which alternate.
